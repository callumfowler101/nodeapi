 // local node modules are established.
 const fs = require('fs');
 const cryptoRandomString = require('crypto-random-string')

module.exports = function(app, db){
    // the app responds to GET and POST requests on port 8000.

    app.get('/form/:type/:medium/:start_date/:end_date', (req, res)=>{

        let reqData = req.params; // parameters are taken from url.

        let sd = new Date(reqData.start_date);
        let ed = new Date (reqData.end_date);

        // a unique code for the start date and end date is generated by adding
        // all the values of the date together.
        let dsd = sd.getDate()+sd.getMonth()+sd.getFullYear();
        let ded = ed.getDate()+ed.getMonth()+ed.getFullYear();

        // the data object is created to contain all the relevant data from 
        // the query.
        let data = {
            "appointment_type": reqData.type,
            "appointment_medium": reqData.medium,
            "start_date": dsd,
            "end_date": ded
        };

        // dateCheck() checks if a given date falls between the two 
        // dates queried.
        function dateCheck(date){
            let ld = new Date(date);
            let ald = ld.getDate()+ld.getMonth()+ld.getFullYear();
            if(data.start_date<=ald&&ald<=data.end_date) return true; 
        }

        // this array will eventually contain all of the possible
        // councellors that match the query 
        let availableCouncellors = [];

        db.forEach(i => {
            let councellor = {}; 

            if(i.appointment_types.includes(data.appointment_type)){
                if(i.appointment_mediums.includes(data.appointment_medium)){
                    councellor.first_name = i.first_name;
                    councellor.last_name = i.last_name;
                    councellor.appointment_type = i.appointment_types;
                    councellor.appointment_medium = i.appointment_mediums;
                    councellor.dates_available = [];
                    i.availability.forEach(j => {
                        let d = new Date(j.datetime);
                        if(dateCheck(d)) councellor.dates_available.push(d);
                    }); 
                    if(councellor.dates_available.length>0) availableCouncellors.push(councellor);
                }
            }     
        });
        // the list of avaliable councellors is sent back as a reponse
        // to the query.
        res.send(availableCouncellors);    
    });

    // the POST request's body is queried to generate the response.
    app.post('/add_dates', (req, res)=>{
        let _id = req.body.id; 
        let dates = req.body.date; // each item with the "date" key is placed in an array called dates.

        let councellor = {}

        db.forEach(i => {
            if(_id === i.counsellor_id){
                councellor.first_name = i.first_name;
                councellor.last_name = i.last_name;
                councellor.dates_added = [];
                dates.forEach(j => {
                    // the time object is structured to match other entries in the data base.
                    let time = {
                        "id": `${cryptoRandomString({length: 22})}`, // cryptoRandomString is used to generate a unique id for this session.
                        "datetime": j // the user can input any data which matches the ISO8601 timecode.
                    };
                    i.availability.push(time);
                    councellor.dates_added.push(j);
                });
            }
        });
        // the database is reformatted before being rewritten with the new data.
        let _db = JSON.stringify(db, null, 2); 
        fs.writeFile("./data.json", _db, ()=>{
            console.log("database updated");
        });
        // the details of the change are sent as a response.
        // it returns the councellors name and the dates they added.
        res.send(councellor);
    });
};

